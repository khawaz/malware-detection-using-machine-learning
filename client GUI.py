from tkinter import *
from tkinter import messagebox
from tkinter import filedialog, ttk, Toplevel
from PIL import ImageTk, Image
import hashlib
import string
import os
import mmap
import pefile
import math
import numpy as np
import array
import socket
import pickle

"""-----------------
Color:
red = #ed4c4c
black= #161415
gray= #777777
white= #ffffff

Font:
Segoe UI Emoji
-----------------"""

# ------- server connection -----------
try:
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    print("Socket created successfully.")

    # Defining port and host
    port = 8008
    host = 'localhost'

    # Connect socket to the host and port
    sock.connect((host, port))
    print('Connection Established.')
except:
    print("connection problems...")

# -------- create main screen --------
root = Tk()
root.title('Malware Detection')
root.geometry('925x500+300+200')
root.config(bg='#fff')
root.resizable(False, False)

# ---------- insert main image & icon --------
img = Image.open('new gui images/Malware.jpg')
img = img.resize((400, 400))
img = ImageTk.PhotoImage(img)
Label(root, image=img, bg='white').place(x=60, y=40)
root.iconbitmap("new gui images/Icon.ico")


# --------- def functions --------------
def UploadAction():
    print("command")
    global filename
    filename = filedialog.askopenfilename()
    direction = Label(frame, text=filename, fg="#777777", bg="#fff",
                      font=("Segoe UI Emoji", 8))
    direction.place(x=100, y=98)
    print('Selected:', filename)


def Scan_command():
    print("Scan command")

    def get_entropy(data):
        if len(data) == 0:
            return 0.0
        # initialize an unsigned long array size 256 filled with 0
        occurences = array.array('L', [0] * 256)
        for x in data:
            occurences[x if isinstance(x, int) else ord(x)] += 1
        entropy = 0
        for x in occurences:
            if x:
                # calculate the probability of the occurrence of each digit in the pe header
                # float is used so that when dividing int by int we get a float
                p_x = float(x) / len(data)
                # calculate Entropy using shanon formula (occurrence of digit) * surprise
                entropy -= p_x * math.log(p_x, 2)
        return entropy

    def get_resources(pe):
        """Extract resources :
        [entropy, size]"""
        resources = []
        if hasattr(pe, 'DIRECTORY_ENTRY_RESOURCE'):
            try:
                for resource_type in pe.DIRECTORY_ENTRY_RESOURCE.entries:
                    if hasattr(resource_type, 'directory'):
                        for resource_id in resource_type.directory.entries:
                            if hasattr(resource_id, 'directory'):
                                for resource_lang in resource_id.directory.entries:
                                    data = pe.get_data(resource_lang.data.struct.OffsetToData,
                                                       resource_lang.data.struct.Size)
                                    size = resource_lang.data.struct.Size
                                    entropy = get_entropy(data)

                                    resources.append([entropy, size])
            except Exception as e:
                return resources
        return resources

    try:
        PEFILE = pefile.PE(filename)
        float_features = []
    except:
        return "File format isn't supported!! (exe,Dll only)"

    entropydata = {}
    resourcedata = {}

    entropy = list(map(lambda x: x.get_entropy(), PEFILE.sections))

    entropydata['SectionsMaxEntropy'] = max(entropy)

    resources = get_resources(PEFILE)

    if len(resources) > 0:
        respurceentropy = list(map(lambda x: x[0], resources))
        entropydata['ResourcesMaxEntropy'] = max(respurceentropy)
        sizes = list(map(lambda x: x[1], resources))
        resourcedata['ResourcesMaxSize'] = max(sizes)
    else:
        entropydata['ResourcesMaxEntropy'] = 0
        resourcedata['ResourcesMaxSize'] = 0

    # 1

    try:
        float_features.append(PEFILE.OPTIONAL_HEADER.MajorLinkerVersion)
    except:
        float_features.append(0)

    # 2

    try:
        float_features.append(PEFILE.OPTIONAL_HEADER.ImageBase)
    except:
        float_features.append(0)

    # 3

    try:
        float_features.append(PEFILE.OPTIONAL_HEADER.MajorOperatingSystemVersion)
    except:
        float_features.append(0)

    # 4

    try:
        float_features.append(PEFILE.OPTIONAL_HEADER.Subsystem)
    except:
        float_features.append(0)

    # 5

    try:
        float_features.append(PEFILE.OPTIONAL_HEADER.DllCharacteristics)
    except:
        float_features.append(0)

    # 6

    float_features.append(entropydata['SectionsMaxEntropy'])

    # 7

    float_features.append(entropydata['ResourcesMaxEntropy'])

    # 8

    float_features.append(resourcedata['ResourcesMaxSize'])

    # end of features

    features = [np.array(float_features)]  # convert to the form [[a,b,c,...]]
    data_string = pickle.dumps(features)
    sock.send(data_string)
    input = sock.recv(1024)
    prediction = pickle.loads(input)
    print(prediction)
    print(prediction[0][0])
    print(prediction[0][1])

    if prediction[0][1] > prediction[0][0]:
        messagebox.showinfo(title="Clean", message="Result : Clean!  \nPercentage: {}%".format(prediction[0][1] * 100))


    else:
        messagebox.showerror(title="Malware",
                               message="Result : Malware!  \nPercentage: {}%".format(prediction[0][0] * 100))

    # at server side!!
    # prediction = model.predict(features)


def Hash_command():
    print("Hash command")

    BUF_SIZE = 65536  # 64kb
    md5 = hashlib.md5()
    sha256 = hashlib.sha256()

    with open(filename, "rb") as f:
        while True:
            data = f.read(BUF_SIZE)
            if not data:
                break
            md5.update(data)
            sha256.update(data)

    messagebox.showinfo(title="Hash Value",
                        message="MD5: " + md5.hexdigest() + "\nSHA256 : " + sha256.hexdigest())


def Fullscan_command():
    print("Full scan command")

    newWindow = Toplevel(root)
    width = 500
    height = 100
    screenwidth = root.winfo_screenwidth()
    screenheight = root.winfo_screenheight()
    alignstr = '%dx%d+%d+%d' % (width, height, (screenwidth - width) / 2, (screenheight - height) / 2)
    newWindow.geometry(alignstr)

    global maliciousFiles
    maliciousFiles = []

    global counter
    counter = 1

    def md5calculator(file):
        BUF_SIZE = 65536  # 64kb
        md5 = hashlib.md5()

        with open(file, "rb") as f:
            while True:
                data = f.read(BUF_SIZE)
                if not data:
                    break
                md5.update(data)

        return md5.hexdigest()

    def searchHashDB(filepath):
        hash = md5calculator(filepath)

        with open('HashDB/VirusShare_0-437_MR4n6_Hash_Sets_Autopsy_2022_Q3-md5.idx', 'r') as file:
            s = mmap.mmap(file.fileno(), 0, access=mmap.ACCESS_READ)
            # content = file.read()

            if s.find(hash) != -1:
                return True
            else:
                return False

            # if hash in content:
            #   maliciousFiles.append(filepath)

    def checkFiles(PATH):
        global counter
        global maliciousFiles
        for filename in os.scandir(PATH):
            try:
                if filename.is_file():
                    print(counter, end=' ')
                    print(filename.path)
                    counter += 1
                    Label(newWindow, text=filename.path).pack()
                    if searchHashDB(filename.path):
                        maliciousFiles.append(filename.path)
            except:
                continue

    def CheckSubDir(PATH):
        for subdir in os.listdir(PATH):
            try:
                CheckSubDir(os.path.join(PATH, subdir))
                checkFiles(os.path.join(PATH, subdir))
            except:
                continue

    drives = ['{}:'.format(drive) + '\\' for drive in string.ascii_uppercase if os.path.exists('{}:'.format(drive))]

    for drive in drives:
        checkFiles(drive)
        CheckSubDir(drive)

        if len(maliciousFiles) == 0:
            print("ALL CLEAN!!")
        else:
            res = ''
            for file in maliciousFiles:
                res = res + file + '\n'
            print(res)


def Partialscan_command():
    print("Partial scan command")
    global maliciousFiles
    maliciousFiles = []

    global counter
    counter = 1

    def md5calculator(file):
        BUF_SIZE = 65536  # 64kb
        md5 = hashlib.md5()

        with open(file, "rb") as f:
            while True:
                data = f.read(BUF_SIZE)
                if not data:
                    break
                md5.update(data)

        return md5.hexdigest()

    def searchHashDB(filepath):
        hash = md5calculator(filepath)

        with open('HashDB/VirusShare_0-437_MR4n6_Hash_Sets_Autopsy_2022_Q3-md5.idx', 'r') as file:
            s = mmap.mmap(file.fileno(), 0, access=mmap.ACCESS_READ)
            # content = file.read()

            if s.find(hash) != -1:
                return True
            else:
                return False

            # if hash in content:
            #   maliciousFiles.append(filepath)

    def checkFiles(PATH):
        global counter
        global maliciousFiles
        for filename in os.scandir(PATH):
            try:
                if filename.is_file():
                    print(counter, end=' ')
                    print(filename.path)
                    counter += 1
                    # tk.Label(newWindow, text=filename.path).pack()
                    if searchHashDB(filename.path):
                        maliciousFiles.append(filename.path)
            except:
                continue

    def CheckSubDir(PATH):
        for subdir in os.listdir(PATH):
            try:
                CheckSubDir(os.path.join(PATH, subdir))
                checkFiles(os.path.join(PATH, subdir))
            except:
                continue

    checkFiles("C:\Windows")
    CheckSubDir("C:\Windows")

    newWindow = Toplevel(root)
    width = 500
    height = 100
    screenwidth = root.winfo_screenwidth()
    screenheight = root.winfo_screenheight()
    alignstr = '%dx%d+%d+%d' % (width, height, (screenwidth - width) / 2, (screenheight - height) / 2)
    newWindow.geometry(alignstr)

    def backtomain():
        newWindow.destroy()
        root.deiconify()

    if len(maliciousFiles) == 0:
        print("ALL CLEAN!!")
        Label(newWindow, text="All Clean!! ", font=("Helvetica 9 bold")).pack()

        Button(newWindow, text="<", font=("Helvetica 18 bold"), command=backtomain).pack()
        root.iconify()
    else:
        res = ''
        for file in maliciousFiles:
            res = res + file + '\n'
        print(res)
        Label(newWindow, text="{}".format(res), font=("Helvetica 9 bold")).pack()

        Button(newWindow, text="<", font=("Helvetica 18 bold"), command=backtomain).pack()
        root.iconify()


# ---------- create frame & button -------
frame = Frame(root, width=350, height=360, bg="#fff")
frame.place(x=500, y=70)
head = Label(frame, text="Malware Detection", fg="#161415", bg="#fff", font=("Segoe UI Emoji", 25, "bold"))
head.place(x=30, y=5)

select = Button(frame, text='Select File:', border=0, bg="#fff", fg="#ed4c4c", cursor='hand2',
                font=("Segoe UI Emoji", 13, "bold"), command=UploadAction)
select.place(x=5, y=90)

scan_img = Image.open('new gui images/Scan.png')
scan_img = scan_img.resize((115, 40))
scan_img = ImageTk.PhotoImage(scan_img)
scan = Button(frame, image=scan_img, border=0, bg="#fff", fg="#fff", cursor='hand2', command=Scan_command)
scan.place(x=55, y=175)

hash_img = Image.open('new gui images/Hash.png')
hash_img = hash_img.resize((115, 40))
hash_img = ImageTk.PhotoImage(hash_img)
hash = Button(frame, image=hash_img, border=0, bg="#fff", fg="#fff", cursor='hand2', command=Hash_command)
hash.place(x=180, y=175)

line_img = Image.open('new gui images/Line.png')
line_img = line_img.resize((284, 4))
line_img = ImageTk.PhotoImage(line_img)
line = Label(frame, image=line_img, border=0, bg="#fff", fg="#fff")
line.place(x=34, y=235)

fullscan_img = Image.open('new gui images/Full Scan.png')
fullscan_img = fullscan_img.resize((115, 40))
fullscan_img = ImageTk.PhotoImage(fullscan_img)
fullscan = Button(frame, image=fullscan_img, border=0, bg="#fff", fg="#fff", cursor='hand2', command=Fullscan_command)
fullscan.place(x=55, y=255)

partialscan_img = Image.open('new gui images/Partial Scan.png')
partialscan_img = partialscan_img.resize((115, 40))
partialscan_img = ImageTk.PhotoImage(partialscan_img)
partialscan = Button(frame, image=partialscan_img, border=0, bg="#fff", fg="#fff", cursor='hand2',
                     command=Partialscan_command)
partialscan.place(x=180, y=255)

root.mainloop()
